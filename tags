!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	makefile	/^CC = gcc$/;"	m
CFLAGS	makefile	/^CFLAGS =-c -WALL -I$/;"	m
GHOST	multiusr.c	/^int GHOST = 3;		\/\/Can change to find best solution.$/;"	v
Hash	lib/lru.h	/^typedef struct Hash{$/;"	s
INC_DIR	makefile	/^INC_DIR = lib$/;"	m
M	multiusr.c	/^struct M{$/;"	s	file:
MAX_SIZE	dram_cache.c	2;"	d	file:
MAX_SIZE	dwf.c	2;"	d	file:
MAX_SIZE	lib/lru.h	15;"	d
MAX_SIZE	lru.c	14;"	d	file:
MAX_SIZE	total_lru.c	2;"	d	file:
MAX_VALUE	multiusr.c	/^volatile int MAX_VALUE;$/;"	v
MAX_VALUE_D	multiusr.c	/^volatile int MAX_VALUE_D;	\/\/maxvalue of pram$/;"	v
MAX_VALUE_P	multiusr.c	/^volatile int MAX_VALUE_P;	\/\/maxvlue of dram$/;"	v
Node	lib/lru.h	/^typedef struct Node{$/;"	s
OBJ_DIR	makefile	/^OBJ_DIR = object$/;"	m
O_VALUE	multiusr.c	/^int O_VALUE;		\/\/orginal size$/;"	v
PERMS	multiusr.c	19;"	d	file:
block_add	lru.c	/^node* block_add(int b_name, node** head, node** tail,int index){$/;"	f
block_alter	lru.c	/^void block_alter(node* n, node** head, node** tail){$/;"	f
block_delete	lru.c	/^int block_delete(node** tail){$/;"	f
block_find	lru.c	/^node* block_find(int b_name, map** h){$/;"	f
blockname	lib/lru.h	/^        unsigned int blockname;$/;"	m	struct:Node
carry	multiusr.c	/^	float carry[4];$/;"	m	struct:M	file:
d_count	multiusr.c	/^int d_count = 0;$/;"	v
delta	multiusr.c	/^int delta;$/;"	v
done	multiusr.c	/^int done = 0;$/;"	v
f	multiusr.c	/^FILE *f, *o;$/;"	v
ghost	lib/lru.h	/^	char ghost;	\/\/ghost buffer$/;"	m	struct:Node
h	multiusr.c	/^int h = 100;$/;"	v
handler	multiusr.c	/^void handler(int sig_num){$/;"	f
hit	multiusr.c	/^volatile int hit = 0;$/;"	v
hit_ghost	multiusr.c	/^volatile int hit_ghost = 0;	\/\/hit on ghost$/;"	v
hit_o	multiusr.c	/^int hit_o= 0;		\/\/hit on original size$/;"	v
hit_t	multiusr.c	/^int hit_t = 0;$/;"	v
hmap_add	lru.c	/^void hmap_add(int blockname, node* n, map** h){$/;"	f
hmap_delete	lru.c	/^void hmap_delete(int blockname, map** h){$/;"	f
hmap_init	lru.c	/^void hmap_init(map ***first){$/;"	f
index	lib/lru.h	/^	unsigned int index;$/;"	m	struct:Node
k	multiusr.c	/^int k = 0;$/;"	v
key	lib/lru.h	/^        int key;$/;"	m	struct:Hash
key	multiusr.c	/^key_t key;$/;"	v
m_buffer	multiusr.c	/^}m_buffer;$/;"	v	typeref:struct:M
main	dram_cache.c	/^int main(int argc, char* argv[]){$/;"	f
main	dwf.c	/^int main(int argc, char* argv[]){$/;"	f
main	multiusr.c	/^int main(int argc, char* argv[]){$/;"	f
main	total_lru.c	/^int main(int argc, char* argv[]){$/;"	f
map	lib/lru.h	/^}map;$/;"	t	typeref:struct:Hash
msqid	multiusr.c	/^int msqid;$/;"	v
mtype	multiusr.c	/^	long mtype;$/;"	m	struct:M	file:
myindex	multiusr.c	/^volatile int myindex = 0;	\/\/index is conflict to finction been declared$/;"	v
myindex_t	multiusr.c	/^int myindex_t = 0;	\/\/total index for trace 	$/;"	v
next	lib/lru.h	/^        struct Hash *next;$/;"	m	struct:Hash	typeref:struct:Hash::Hash
next	lib/lru.h	/^        struct Node *next;$/;"	m	struct:Node	typeref:struct:Node::Node
node	lib/lru.h	/^}node;$/;"	t	typeref:struct:Node
o	multiusr.c	/^FILE *f, *o;$/;"	v
o_size	lib/lru.h	/^	char o_size;	\/\/original size$/;"	m	struct:Node
old_hit	multiusr.c	/^float old_hit = 0.0;$/;"	v
old_hit_ghost	multiusr.c	/^float old_hit_ghost = 0.0;	\/\/hit on ghost$/;"	v
old_hit_o	multiusr.c	/^float old_hit_o= 0.0;		\/\/hit on original size$/;"	v
p	multiusr.c	/^void p (void){$/;"	f
p_count	multiusr.c	/^int p_count = 0;$/;"	v
pid	multiusr.c	/^pid_t pid;$/;"	v
pre	lib/lru.h	/^        struct Node *pre;$/;"	m	struct:Node	typeref:struct:Node::Node
slope	multiusr.c	/^float slope;$/;"	v
slope_child	multiusr.c	/^float slope_child;$/;"	v
type	lib/lru.h	/^	int type;$/;"	m	struct:Node
value	lib/lru.h	/^        void* value;$/;"	m	struct:Hash
write_p	multiusr.c	/^int write_p = 0;$/;"	v
write_p_t	multiusr.c	/^int write_p_t = 0;$/;"	v
